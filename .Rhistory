```
## Richness
This returns observed richness with given detection threshold(s).
```{r divest, warning=FALSE, message=FALSE, fig.height=3, fig.width=5}
tab <- richness(pseq)
kable(head(tab))
```
## Dominance
The dominance index refers to the abundance of the most abundant species. Various dominance indices are available (see the function help for a list of options).
```{r dominance, warning=FALSE, message=FALSE}
# Absolute abundances for the single most abundant taxa in each sample
tab <- dominance(pseq, index = "all")
kable(head(tab))
```
We also have a function to list the dominating (most abundant) taxa in each sample.
```{r dominant, warning=FALSE, message=FALSE, results="hide"}
dominant(pseq)
```
## Rarity and low abundance
The rarity indices quantify the concentration of rare or low abundance taxa. Various rarity indices are available (see the function help for a list of options).
```{r lowab, warning=FALSE, message=FALSE}
tab <- rarity(pseq, index = "all")
kable(head(tab))
```
## Coverage
The coverage index gives the number of groups needed to have a given proportion of the ecosystem occupied (by default 0.5 ie 50%).
```{r coverage, warning=FALSE, message=FALSE, eval=FALSE}
tab <- coverage(pseq, threshold = 0.5)
kable(head(tab))
```
## Core abundance
The core_abundance function refers to the relative proportion of the core species. Non-core abundance provides the complement (1-x; see rare_abundance).
```{r divest5, warning=FALSE, message=FALSE}
tab <- core_abundance(pseq, detection = .1/100, prevalence = 50/100)
```
## Gini index
Gini index is a common measure for inequality in economical income. The inverse gini index (1/x) can also be used as a community diversity measure.
```{r divest6, warning=FALSE, message=FALSE}
tab <- inequality(pseq)
```
## Evenness
Various evenness measures are also available.
```{r evenness, warning=FALSE, message=FALSE}
tab <- evenness(pseq, "all")
kable(head(tab))
```
For tutorial on plotting the output of alpha diversity please check [PlotDiversity](PlotDiversity.html)
library(microbiome)
library(knitr)
data(dietswap)
pseq <- dietswap
tab <- alpha(pseq, index = "all")
kable(head(tab))
tab <- alpha(pseq, index = "all")
kable(head(tab))
tab <- richness(pseq)
kable(head(tab))
# Absolute abundances for the single most abundant taxa in each sample
tab <- dominance(pseq, index = "all")
kable(head(tab))
# Absolute abundances for the single most abundant taxa in each sample
tab <- dominance(pseq, index = "all")
kable(head(tab))
dominant(pseq)
tab <- rarity(pseq, index = "all")
kable(head(tab))
tab <- coverage(pseq, threshold = 0.5)
kable(head(tab))
tab <- core_abundance(pseq, detection = .1/100, prevalence = 50/100)
tab <- inequality(pseq)
tab <- evenness(pseq, "all")
kable(head(tab))
rmarkdown::render('Betadiversity.rmd','html_document')
rmarkdown::render('Diversity.rmd','html_document')
rmarkdown::render('Diversity.rmd','html_document')
rmarkdown::render('Betadiversity.rmd','html_document')
rmarkdown::render('Betadiversity.rmd','html_document')
getwd()
library(IRanges)
%/??
%/
??%/
install.packages('ggvis')
library(ggvis)
library(ggvis)
`r mean(c(3,4,2,3,4,4,4,5,6,7))
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(knitr)
mean(c(3,4,2,3,4,4,4,5,6,7))
mean(c(3,4,2,3,4,4,4,5,6,7))
### The mean of all values is:`r mean(c(3,4,2,3,4,4,4,5,6,7))`
**The mean of all values is:**`r mean(c(3,4,2,3,4,4,4,5,6,7))`
**The mean of all values is:**`r mean(c(3,4,2,3,4,4,4,5,6,7))`
```{r simple_sum, results = 'hide'}
2 + 2
```
my_html_document <- function(template = "path_to_custom_template", ...) {
base_format <- rmarkdown::html_document(...)
template_arg <- which(base_format$pandoc$args == "--template") + 1L
base_format$pandoc$args[template_arg] <- template
base_format
}
######
my_html_document(template = 'C:/Users/witasa/Seafile/My LibraryImportant7New_microbiome/tutorials')
my_html_document(template = 'C:/Users/witasa/Seafile/My LibraryImportant7New_microbiome/tutorials/Mixedmodels.Rmd')
my_html_document(template = 'C:/Users/witasa/Seafile/My LibraryImportant7New_microbiome/tutorials/Mixedmodels.Rmd')
rmarkdown::render()
rmarkdown::render('Mixedmodels.rmd','html_document')
getwd()
times <- c()
for (myfile in fs) {
times[[myfile]] <- system.time(rmarkdown::render(myfile))
}
theme_set(theme_bw(40))
theme_set(theme_bw(40))
df <- as.data.frame(t(sapply(times, identity)))
df$file <- rownames(df)
dfm <- as_tibble(melt(df, id = "file")) %>%
filter(variable %in% c("user.self", "elapsed")) %>%
arrange(value) %>%
mutate(file = factor(file, levels = unique(file)))
library(reshape2)
library(reshape2)
theme_set(theme_bw(40))
df <- as.data.frame(t(sapply(times, identity)))
df$file <- rownames(df)
dfm <- as_tibble(melt(df, id = "file")) %>%
filter(variable %in% c("user.self", "elapsed")) %>%
arrange(value) %>%
mutate(file = factor(file, levels = unique(file)))
p <- ggplot(dfm, aes(x = file, fill = variable, y = value)) +
geom_bar(stat = "identity", position = "dodge", color = "black") +
coord_flip() + labs(x = "", y = "Time (s)")
print(p)
for (myfile in fs) {
times[[myfile]] <- system.time(rmarkdown::render(myfile))
}
best <- fit[[which.min(lplc)]]
times <- c()
# Render all files
for (myfile in fs) {
times[[myfile]] <- system.time(rmarkdown::render(myfile))
}
venn( list(ANOVA = taxa.anova,DESeq2 = taxa.deseq) )
# Check overlap
# Most DESEq2 taxa are confirmed with ANOVA
library(gplots)
venn( list(ANOVA = taxa.anova,DESeq2 = taxa.deseq) )
# Load libraries
library(microbiome)
library(ggplot2)
# Probiotics intervention example data
data(dietswap)
# Only check the core taxa to speed up examples
pseq <- core(dietswap, detection = 50, prevalence = 80/100)
library(phyloseq)
library(reshape2)
library(DESeq2)
# Running the DESeq2 analysis
ds2 <- phyloseq_to_deseq2(pseq, ~ nationality)
dds <- DESeq(ds2)
res <- results(dds)
df <- as.data.frame(res)
df$taxon <- rownames(df)
df <- df %>% arrange(log2FoldChange, padj)
library(knitr)
print(head(kable((df))))
# Identify top taxa based on standard ANOVA
source(system.file("extdata/check_anova.R", package = "microbiome"))
ano <- check_anova(pseq, "nationality");
ano$log2FC <- log2(ano$ave.AFR) - log2(ano$ave.AAM)
taxa.anova <- as.character(subset(ano, padj < 0.01 & abs(log2FC) > log2(2))$taxa)
# lowPick the top taxa based on DESEq2
taxa.deseq <- subset(res, padj < 0.01 & abs(log2FoldChange) > log2(2))$taxon
# Check overlap
# Most DESEq2 taxa are confirmed with ANOVA
library(gplots)
venn( list(ANOVA = taxa.anova,DESeq2 = taxa.deseq) )
# Also the est p-values are well correlated (higher not so)
mf<-data.frame(df$padj, ano$padj)
p<-ggplot(mf, aes(x = log10(df$padj), y = log10(ano$padj))) + xlab('DESeq2 adjusted p-value') + ylab('ANOVA adjusted p-value')
p<- p + geom_point()
#plot(xlim=log10(df$padj), log10(ano$padj), type = 'l', xlim = "DESeq2 adjusted p-value",  ylim("ANOVA adjusted p-value"))
venn( list(ANOVA = taxa.anova,DESeq2 = taxa.deseq))
print(p)
# Identify top taxa based on standard ANOVA
source(system.file("extdata/check_anova.R", package = "microbiome"))
ano <- check_anova(pseq, "nationality");
ano$log2FC <- log2(ano$ave.AFR) - log2(ano$ave.AAM)
taxa.anova <- as.character(subset(ano, padj < 0.01 & abs(log2FC) > log2(2))$taxa)
# lowPick the top taxa based on DESEq2
taxa.deseq <- subset(res, padj < 0.01 & abs(log2FoldChange) > log2(2))$taxon
# Check overlap
# Most DESEq2 taxa are confirmed with ANOVA
library(gplots)
#venn( list(ANOVA = taxa.anova,DESeq2 = taxa.deseq) )
# Also the est p-values are well correlated (higher not so)
mf<-data.frame(df$padj, ano$padj)
p<-ggplot(mf, aes(x = log10(df$padj), y = log10(ano$padj))) + xlab('DESeq2 adjusted p-value') + ylab('ANOVA adjusted p-value')
p<- p + geom_point()
#plot(xlim=log10(df$padj), log10(ano$padj), type = 'l', xlim = "DESeq2 adjusted p-value",  ylim("ANOVA adjusted p-value"))
venn( list(ANOVA = taxa.anova,DESeq2 = taxa.deseq))
print(p)
p<-ggplot(mf, aes(x = log10(df$padj), y = log10(ano$padj)), color = df.padj) + xlab('DESeq2 adjusted p-value') + ylab('ANOVA adjusted p-value')
p<- p + geom_point()
print(p)
# Also the est p-values are well correlated (higher not so)
mf<-data.frame(df$padj, ano$padj)
p<-ggplot(mf, aes(x = log10(df$padj), y = log10(ano$padj)), color = 'df.padj') + xlab('DESeq2 adjusted p-value') + ylab('ANOVA adjusted p-value')
p<- p + geom_point()
p
getwd()
rmarkdown::render('deseq2.rmd','html_document')
times <- c()
# Render all files
for (myfile in fs) {
times[[myfile]] <- system.time(rmarkdown::render(myfile))
}
library(microbiome)
library(DirichletMultinomial)
library(reshape2)
library(magrittr)
library(dplyr)
# Load example data
data(dietswap)
pseq <- dietswap
# To speed up, only consider the core taxa
# that are prevalent at 0.1% relative abundance in 50% of the samples
# (note that this is not strictly correct as information is
# being discarded; one alternative would be to aggregate rare taxa)
pseq.comp <- microbiome::transform(pseq, "compositional")
taxa <- core_members(pseq.comp, detection = 0.1/100, prevalence = 50/100)
pseq <- prune_taxa(taxa, pseq)
# Pick the OTU count matrix
# and convert it into samples x taxa format
dat <- abundances(pseq)
count <- as.matrix(t(dat))
fit <- mclapply(1:3, dmn, count = count, verbose=TRUE)
lplc <- sapply(fit, laplace) # AIC / BIC / Laplace
aic  <- sapply(fit, AIC) # AIC / BIC / Laplace
bic  <- sapply(fit, BIC) # AIC / BIC / Laplace
#plot(lplc, type="b", xlab="Number of Dirichlet Components", ylab="Model Fit")
#lines(aic, type="b", lty = 2)
#lines(bic, type="b", lty = 3)
best <- fit[[which.min(lplc)]]
mixturewt(best)
ass <- apply(mixture(best), 1, which.max)
for (k in seq(ncol(fitted(best)))) {
d <- melt(fitted(best))
colnames(d) <- c("OTU", "cluster", "value")
d <- subset(d, cluster == k) %>%
# Arrange OTUs by assignment strength
arrange(value) %>%
mutate(OTU = factor(OTU, levels = unique(OTU))) %>%
# Only show the most important drivers
filter(abs(value) > quantile(abs(value), 0.8))
p <- ggplot(d, aes(x = OTU, y = value)) +
geom_bar(stat = "identity") +
coord_flip() +
labs(title = paste("Top drivers: community type", k))
print(p)
}
getwd()
rmarkdown::render('README.rmd','md_document')
getwd()
setwd('D:/Seafile/My Library/Important/New_microbiome/tutorials/main')
rmarkdown::render('README.rmd','md_document')
getwd()
setwd('D:/Seafile/My Library/Important/New_microbiome/tutorials')
setwd('D:/Seafile/My Library/Important/New_microbiome/tutorials/main')
setwd('D:/Seafile/My Library/Important/New_microbiome/tutorials')
rmarkdown::render('README.rmd','md_document')
getwd()
rmarkdown::render('README.rmd','md_document')
rmarkdown::render('README.rmd','md_document')
knit2 = function(...) {
pdf.options(encoding='ISOLatin2.enc')
knitr::knit(...)
}
rmarkdown::render('README.rmd','md_document')
rmarkdown::render('README.rmd','md_document')
getwd()
rmarkdown::render('README.rmd','md_document')
getwd()
setwd('D:/Seafile/My Library/Important/New_microbiome/tutorials/main')
times <- c()
# Render all files
for (myfile in fs) {
times[[myfile]] <- system.time(rmarkdown::render(myfile))
}
rmarkdown::render("info.Rmd")
theme_set(theme_bw(40))
df <- as.data.frame(t(sapply(times, identity)))
df$file <- rownames(df)
dfm <- as_tibble(melt(df, id = "file")) %>%
filter(variable %in% c("user.self", "elapsed")) %>%
arrange(value) %>%
mutate(file = factor(file, levels = unique(file)))
library(tibble)
theme_set(theme_bw(40))
df <- as.data.frame(t(sapply(times, identity)))
df$file <- rownames(df)
dfm <- as_tibble(melt(df, id = "file")) %>%
filter(variable %in% c("user.self", "elapsed")) %>%
arrange(value) %>%
mutate(file = factor(file, levels = unique(file)))
df <- as.data.frame(t(sapply(times, identity)))
df$file <- rownames(df)
dfm <- as_tibble(melt(df, id = "file")) %>%
filter(variable %in% c("user.self", "elapsed")) %>%
arrange(value) %>%
mutate(file = factor(file, levels = unique(file)))
library(tibble)
theme_set(theme_bw(40))
df <- as.data.frame(t(sapply(times, identity)))
df$file <- rownames(df)
dfm <- as_tibble(melt(df, id = "file")) %>%
filter(variable %in% c("user.self", "elapsed")) %>%
arrange(value) %>%
mutate(file = factor(file, levels = unique(file)))
library(magrittr)
theme_set(theme_bw(40))
df <- as.data.frame(t(sapply(times, identity)))
df$file <- rownames(df)
dfm <- as_tibble(melt(df, id = "file")) %>%
filter(variable %in% c("user.self", "elapsed")) %>%
arrange(value) %>%
mutate(file = factor(file, levels = unique(file)))
dfm <- as_tibble(melt(df, id = "file")) %>%
filter(variable %>% c("user.self", "elapsed")) %>%
arrange(value) %>%
mutate(file = factor(file, levels = unique(file)))
f<-4
f1<-2
f2<-c(1,2,3,4,5,6,7)
f %in f2
f %in% f2
98 %in% f2
library(tibble)
library(magrittr)
theme_set(theme_bw(40))
df <- as.data.frame(t(sapply(times, identity)))
df$file <- rownames(df)
dfm <- as_tibble(melt(df, id = "file")) %>%
filter(variable %in% c("user.self", "elapsed")) %>%
arrange(value) %>%
mutate(file = factor(file, levels = unique(file)))
times <- c()
# Render all files
for (myfile in fs) {
times[[myfile]] <- system.time(rmarkdown::render(myfile))
}
rmarkdown::render("info.Rmd")
# Download the required R packages and then the HITChip Atlas data set
library(microbiome)
data(atlas1006)
tab <- alpha(atlas1006, index = c("shannon", "invsimpson"))
library(knitr)
kable(head(tab))
getwd()
setwd('D:/Seafile/My Library/Important/New_microbiome/tutorials')
times <- c()
# Render all files
for (myfile in fs) {
times[[myfile]] <- system.time(rmarkdown::render(myfile))
}
rmarkdown::render("info.Rmd")
library(microbiome)
library(DirichletMultinomial)
library(reshape2)
library(magrittr)
library(dplyr)
# Load example data
data(dietswap)
pseq <- dietswap
# To speed up, only consider the core taxa
# that are prevalent at 0.1% relative abundance in 50% of the samples
# (note that this is not strictly correct as information is
# being discarded; one alternative would be to aggregate rare taxa)
pseq.comp <- microbiome::transform(pseq, "compositional")
taxa <- core_members(pseq.comp, detection = 0.1/100, prevalence = 50/100)
pseq <- prune_taxa(taxa, pseq)
# Pick the OTU count matrix
# and convert it into samples x taxa format
dat <- abundances(pseq)
count <- as.matrix(t(dat))
fit <- mclapply(1:3, dmn, count = count, verbose=TRUE)
lplc <- sapply(fit, laplace) # AIC / BIC / Laplace
aic  <- sapply(fit, AIC) # AIC / BIC / Laplace
bic  <- sapply(fit, BIC) # AIC / BIC / Laplace
#plot(lplc, type="b", xlab="Number of Dirichlet Components", ylab="Model Fit")
#lines(aic, type="b", lty = 2)
#lines(bic, type="b", lty = 3)
best <- fit[[which.min(lplc)]]
mixturewt(best)
ass <- apply(mixture(best), 1, which.max)
for (k in seq(ncol(fitted(best)))) {
d <- melt(fitted(best))
colnames(d) <- c("OTU", "cluster", "value")
d <- subset(d, cluster == k) %>%
# Arrange OTUs by assignment strength
arrange(value) %>%
mutate(OTU = factor(OTU, levels = unique(OTU))) %>%
# Only show the most important drivers
filter(abs(value) > quantile(abs(value), 0.8))
p <- ggplot(d, aes(x = OTU, y = value)) +
geom_bar(stat = "identity") +
coord_flip() +
labs(title = paste("Top drivers: community type", k))
print(p)
}
lplc <- sapply(fit, laplace) # AIC / BIC / Laplace
aic  <- sapply(fit, AIC) # AIC / BIC / Laplace
bic  <- sapply(fit, BIC) # AIC / BIC / Laplace
#plot(lplc, type="b", xlab="Number of Dirichlet Components", ylab="Model Fit")
#lines(aic, type="b", lty = 2)
#lines(bic, type="b", lty = 3)
best <- fit[[which.min(lplc)]]
lplc <- sapply(fit, laplace) # AIC / BIC / Laplace
aic  <- sapply(fit, AIC) # AIC / BIC / Laplace
bic  <- sapply(fit, BIC) # AIC / BIC / Laplace
plot(lplc, type="b", xlab="Number of Dirichlet Components", ylab="Model Fit")
lplc <- sapply(fit, laplace) # AIC / BIC / Laplace
aic  <- sapply(fit, AIC) # AIC / BIC / Laplace
bic  <- sapply(fit, BIC) # AIC / BIC / Laplace
#plot(lplc, type="b", xlab="Number of Dirichlet Components", ylab="Model Fit")
#lines(aic, type="b", lty = 2)
#lines(bic, type="b", lty = 3)
#best <- fit[[which.min(lplc)]]
mixturewt(best)
mixturewt(best)
data.frame(pi = object@mixture$Weight, theta = colSums(fitted(object)))
fit <- mclapply(1:3, dmn, count = count, verbose=TRUE)
mixturewt(best)
ass <- apply(mixture(best), 1, which.max)
for (k in seq(ncol(fitted(best)))) {
d <- melt(fitted(best))
colnames(d) <- c("OTU", "cluster", "value")
d <- subset(d, cluster == k) %>%
# Arrange OTUs by assignment strength
arrange(value) %>%
mutate(OTU = factor(OTU, levels = unique(OTU))) %>%
# Only show the most important drivers
filter(abs(value) > quantile(abs(value), 0.8))
p <- ggplot(d, aes(x = OTU, y = value)) +
geom_bar(stat = "identity") +
coord_flip() +
labs(title = paste("Top drivers: community type", k))
print(p)
}
library(BiocInstaller)
source("http://www.bioconductor.org/biocLite.R")
library(BiocManager)
source("https://bioconductor.org/install")
library(BiocManager)
source("https://bioconductor.org/install")
library(BiocManager)
source("https://bioconductor.org/install/#install-R")
library(devtools) # Load the devtools package
install_github("microbiome/microbiome") # Install the package
library(BiocManager)
source("https://bioconductor.org")
source("https://bioconductor.org/biocLite.R")
source("https://bioconductor.org/install")
library(BiocManager)
#source("https://bioconductor.org/install")
useDevel()
library(BiocManager)
#source("https://bioconductor.org/install")
#useDevel()
BiocManager::install("microbiome")
version('microbiome')
BiocManager::version('microbiome')
BiocManager::version()
microbiome::version()
library(BiocManager)
#source("https://bioconductor.org/install")
#useDevel()
BiocManager::install("microbiome")
remove.packages("microbiomeutilities", lib="~/R/win-library/3.6")
remove.packages("microbiome", lib="~/R/win-library/3.6")
# Installing from Bioconductor
source("http://www.bioconductor.org/biocLite.R")
# Installing from Bioconductor
#source("http://www.bioconductor.org/biocLite.R")
BiocManager::install("MASS")
# Installing from CRAN
install.packages("sorvi")
# Installing from Github
library(devtools)
install_github("antagomir/netresponse")
library(netresponse)
library(netresponse)
BiocManager::version()
library(BiocManager)
#source("https://bioconductor.org/install")
#useDevel()
BiocManager::install(version='devel')
BiocManager::install("microbiome")
library(microbiome)
library(BiocManager)
#source("https://bioconductor.org/install")
#useDevel()
BiocManager::install(version='devel')
BiocManager::install("microbiome")
n
library(devtools) # Load the devtools package
install_github("microbiome/microbiome") # Install the package
library(devtools) # Load the devtools package
getwd()
getwd()

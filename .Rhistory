rmarkdown::render('DMM.Rmd','all')
library("devtools")
install_github("microbiome/microbiome")
#library("devtools")
#install_github("microbiome/microbiome")
# Dissimilarity-Overlap analysis
library(microbiome)
data(atlas1006)
# Dissimilarity
d <- distance(transform(atlas1006), "jsd", parallel=TRUE)
# Dissimilarity
d <- distance(transform(atlas1006), "jsd", parallel=TRUE)
data(atlas1006)
# Dissimilarity
d <- distance(transform(atlas1006), "jsd", parallel=TRUE)
# Dissimilarity
library(IRanges)
d <- distance(transform(atlas1006), "jsd", parallel=TRUE)
atlas1006
# Overlap
o <- overlap(atlas1006, detection = 0.2/100)
overlap <- function(x, detection = 0) {
# taxa x samples
a <- abundances(transform(x, "compositional"))
# samples x samples
O <- matrix(0, nrow = ncol(a), ncol = ncol(a))
for (i in seq_len(ncol(a)-1)) {
for (j in seq(i+1, ncol(a))) {
O[i, j] <- O[j, i] <- olap(a[,i], a[, j], detection = detection)
}
}
O
}
olap <- function (x, y, detection) {
inds <- which(x > detection & y > detection)
x <- x[inds]
y <- y[inds]
o <- (sum(x) + sum(y))/2
}
# Overlap
o <- overlap(atlas1006, detection = 0.2/100)
is.phyloseq <- function (x) {
length(x) == 1 && is(x) == "phyloseq"
}
d <- distance(transform(atlas1006), "jsd", parallel=TRUE)
# Overlap
o <- overlap(atlas1006, detection = 0.2/100)
o
# Dissimilarity
library(IRanges)
d <- distance(transform(atlas1006, 'clr'), "jsd", parallel=TRUE)
d <- distance(transform(atlas1006), "jsd", parallel=TRUE)
# Compare
dvec <- d[lower.tri(d)]
ovec <- o[lower.tri(o)]
# Assess rough correlation
cc <- cor(dvec, ovec, method = "spearman", use = "pairwise.complete.obs")
transform(atlas1006)
"jsd"
library(phyloseq)
# Dissimilarity
d <- phyloseq::distance(transform(atlas1006), "jsd", parallel=TRUE)
# Dissimilarity
d <- phyloseq::distance(transform(atlas1006), "jsd", parallel=TRUE)
#library("devtools")
#install_github("microbiome/microbiome")
# Dissimilarity-Overlap analysis
library(microbiome)
data(atlas1006)
# Dissimilarity
d <- phyloseq::distance(transform(atlas1006), "jsd", parallel=TRUE)
rmarkdown::render('DOC.Rmd','all')
library(microbiome)
library(phyloseq)
library(ggplot2)
data(dietswap)
pseq <- dietswap
# Convert to compositional data
pseq.rel <- microbiome::transform(pseq, "compositional")
# Pick core taxa with with the given prevalence and detection limits
pseq.core <- core(pseq.rel, detection = .1/100, prevalence = 90/100)
# Use relative abundances for the core
pseq.core <- microbiome::transform(pseq.core, "compositional")
# Ordinate the data
set.seed(4235421)
# proj <- get_ordination(pseq, "MDS", "bray")
ord <- ordinate(pseq, "MDS", "bray")
plot_ordination(pseq, ord, color = "nationality") +
geom_point(size = 5)
# With samples
pseq.cca <- ordinate(pseq, "CCA")
p <- plot_ordination(pseq, pseq.cca,
type = "samples", color = "nationality")
p <- p + geom_point(size = 4)
print(p)
# With taxa:
p <- plot_ordination(pseq, pseq.cca,
type = "taxa", color = "Phylum")
p <- p + geom_point(size = 4)
print(p)
plot_ordination(pseq, pseq.cca,
type = "split", shape = "nationality",
color = "Phylum", label = "nationality")
library(vegan)
library(microbiome)
library(Rtsne) # Load package
set.seed(423542)
method <- "tsne"
trans <- "hellinger"
distance <- "euclidean"
# Distance matrix for samples
ps <- microbiome::transform(pseq, trans)
# Calculate sample similarities
dm <- vegdist(otu_table(ps), distance)
# Run TSNE
tsne_out <- Rtsne(dm, dims = 2)
proj <- tsne_out$Y
rownames(proj) <- rownames(otu_table(ps))
library(ggplot2)
p <- plot_landscape(proj, legend = T, size = 1)
print(p)
rmarkdown::render('Ordination.Rmd','all')
# With samples
pseq.cca <- ordinate(pseq, "CCA")
p <- plot_ordination(pseq, pseq.cca,
type = "samples", color = "nationality")
p <- p + geom_point(size = 4)
print(p)
# With taxa:
p <- plot_ordination(pseq, pseq.cca,
type = "taxa", color = "Phylum")
p <- p + geom_point(size = 4)
print(p)
rmarkdown::render('Output.Rmd','all')
rmarkdown::render('Output.Rmd','all')
rmarkdown::render('Output.Rmd','all')
# Load the example data
library(microbiome)
library(dplyr)
data(atlas1006)
# Rename the example data
pseq <- atlas1006
# Focus on specific DNA extraction method
pseq <- pseq %>% subset_samples(DNA_extraction_method == "r")
# Keep prevalent taxa (HITChip signal >3 in >20 percent of the samples)
pseq <- core(pseq, detection = 10^3, prevalence = .2)
# Use relative abundances
pseq <- microbiome::transform(pseq, "compositional")
# For cross-sectional analysis, include
# only the zero time point:
pseq0 <- subset_samples(pseq, time == 0)
# Bimodality is better estimated from log10 abundances
pseq0.log10 <- microbiome::transform(pseq0, "log10")
bimodality <- bimodality(pseq0.log10, method = "potential_analysis", bs.iter = 20)
bimodality <- bimodality(pseq0.log10, method = "potential_analysis", bs.iter = 20, verbose = T)
pseq0.log10
bimodality <- bimodality(pseq0.log10, method = "potential_analysis", bs.iter = 20, verbose = T)
overlap <- function(x, detection = 0) {
# taxa x samples
a <- abundances(transform(x, "compositional"))
# samples x samples
O <- matrix(0, nrow = ncol(a), ncol = ncol(a))
for (i in seq_len(ncol(a)-1)) {
for (j in seq(i+1, ncol(a))) {
O[i, j] <- O[j, i] <- olap(a[,i], a[, j], detection = detection)
}
}
O
}
olap <- function (x, y, detection) {
inds <- which(x > detection & y > detection)
x <- x[inds]
y <- y[inds]
o <- (sum(x) + sum(y))/2
}
###
Skip to content
Search or jump toâ€¦
Pull requests
Issues
Marketplace
Explore
@WisamSaleem
microbiome
/
microbiome
27
139
36
Code
Issues 34
Pull requests 0 Actions
Projects 0
Wiki
Security 0
Insights
microbiome/R/bimodality.R
@antagomir antagomir bioc fixes
8daa62a on Mar 29
Executable File  316 lines (268 sloc)  10.4 KB
#' @title Bimodality Analysis
#' @description Estimate bimodality scores.
#' @param x A vector, matrix, or a phyloseq object
#' @param method bimodality quantification method
#' ('potential_analysis', 'Sarle.finite.sample', or 'Sarle.asymptotic').
#' If method='all', then a data.frame with all scores is returned.
#' @param bw.adjust Bandwidth adjustment
#' @param bs.iter Bootstrap iterations
#' @param min.density minimum accepted density for a maximum;
#' as a multiple of kernel height
#' @param verbose Verbose
#' @inheritParams potential_analysis
#' @return A list with following elements:
#' \itemize{
#' \item{score}{Fraction of bootstrap samples where multiple modes are
#' observed}
#' \item{nmodes}{The most frequently observed number of modes in
#' bootstrap sampling results.}
#' \item{results}{Full results of potential_analysis for each row of the
#' input matrix.}
#' }
#' @details
#' \itemize{
#' \item{Sarle.finite.sample}{ Coefficient of bimodality for
#' finite sample. See SAS 2012.}
#' \item{Sarle.asymptotic}{ Coefficient of bimodality, used and described
#' in Shade et al. (2014) and Ellison AM (1987).}
#' \item{potential_analysis}{ Repeats potential analysis
#' (Livina et al. 2010) multiple times with bootstrap sampling for
#' each row of the input data (as in Lahti et al. 2014) and returns
#' the bootstrap score.}
#' }
#'
#' The coefficient lies in (0, 1).
#'
#' The 'Sarle.asymptotic' version is defined as
#' \deqn{b=(g^2 + 1) / k}.
#' This is coefficient of bimodality from Ellison
#' AM Am. J. Bot. 1987, for microbiome analysis it has been used for
#' instance in Shade et al. 2014.
#' The formula for 'Sarle.finite.sample' (SAS 2012):
#' \deqn{b=\frac{g^2 + 1}{k + (3(n-1)^2)/((n-2)(n-3))}}
#' where n is sample size and
#' In both formulas, \eqn{g} is sample skewness and \eqn{k} is the kth
#' standardized moment (also called the sample kurtosis, or
#' excess kurtosis).
#'
#' @seealso A classical test of multimodality is provided by \code{dip.test}
#' in the \pkg{DIP} package.
#'
#' @references
#' \itemize{
#' \item{}{Livina et al. (2010). Potential analysis
#' reveals changing number of climate states during the last 60
#' kyr. \emph{Climate of the Past}, 6, 77-82.}
#' \item{}{Lahti et al. (2014). Tipping elements of the human intestinal
#' ecosystem. \emph{Nature Communications} 5:4344.}
#' \item{}{Shade et al. mBio 5(4):e01371-14, 2014.}
#' \item{}{AM Ellison, Am. J. Bot 74:1280-8, 1987.}
#' \item{}{SAS Institute Inc. (2012). SAS/STAT 12.1 user's guide. Cary, NC.}
#' \item{}{To cite the microbiome R package, see citation('microbiome')}
#' }
#' @export
#' @author Leo Lahti \email{leo.lahti@@iki.fi}
#' @examples
#' # In practice, use more bootstrap iterations
#' b <- bimodality(c(rnorm(100, mean=0), rnorm(100, mean=5)),
#'     method = "Sarle.finite.sample", bs.iter=5)
#' # The classical DIP test:
#' # quantifies unimodality. Values range between 0 to 1.
#' # dip.test(x, simulate.p.value=TRUE, B=200)$statistic
#' # Values less than 0.05 indicate significant deviation from unimodality.
#' # Therefore, to obtain an increasing multimodality score, use
#' # library(diptest)
#' # multimodality.dip <- apply(abundances(pseq), 1,
#' # function (x) {1 - unname(dip.test(x)$p.value)})
#'
#' @keywords utilities
bimodality <- function(x, method="potential_analysis", peak.threshold=1,
bw.adjust=1, bs.iter=100, min.density=1, verbose=TRUE) {
accepted <- intersect(method, c("potential_analysis",
"Sarle.finite.sample", "Sarle.asymptotic"))
if (length(method) > 1 || method == "all") {
method <- accepted
tab <- NULL
for (meth in method) {
b <- bimodality(x, method=meth, peak.threshold, bw.adjust,
bs.iter, min.density, verbose)
tab <- cbind(tab, b)
}
colnames(tab) <- method
tab <- as.data.frame(tab)
return(tab)
}
if (is.vector(x)) {
if (method %in% c("Sarle.finite.sample", "Sarle.asymptotic")) {
s <- bimodality_sarle(x, type=method)
} else if (method == "potential_analysis") {
if (length(unique(x)) == 1) {
s <- 0
} else {
# Shift the data. This does not affect mode detection but
# avoids errors with nonnegatives.
s <- multimodality(x, peak.threshold, bw.adjust,
bs.iter, min.density, verbose)$score
}
}
} else if (is.matrix(x)) {
s <- apply(x, 1, function(xi) {
bimodality(xi, method=method, peak.threshold=peak.threshold,
bw.adjust=bw.adjust,
bs.iter=bs.iter, min.density=min.density, verbose=verbose)
})
} else if (is.phyloseq(x)) {
# Pick the data from phyloseq object
x <- abundances(x)
s <- bimodality(x, method=method, peak.threshold=peak.threshold,
bw.adjust=bw.adjust,
bs.iter=bs.iter, min.density=min.density, verbose=verbose)
}
s
}
#' @title Multimodality Score
#' @description Multimodality score based on bootstrapped potential analysis.
#' @param x A vector, or data matrix (variables x samples)
#' @param bw.adjust Bandwidth adjustment
#' @param bs.iter Bootstrap iterations
#' @param min.density minimum accepted density for a maximum;
#' as a multiple of kernel height
#' @param verbose Verbose
#' @inheritParams potential_analysis
#' @return A list with following elements:
#' \itemize{
#' \item{score}{Fraction of bootstrap samples with multiple
#' observed modes}
#' \item{nmodes}{The most frequently observed number of modes
#' in bootstrap}
#' \item{results}{Full results of potential_analysis for each
#' row of the input matrix.}
#' }
#' @details Repeats potential analysis (Livina et al. 2010) multiple times
#' with bootstrap sampling for each row of the input data
#' (as in Lahti et al. 2014) and returns the specified results.
#' @author Leo Lahti \email{leo.lahti@@iki.fi}
#' @examples
#' #data(peerj32)
#' #s <- multimodality(t(peerj32$microbes[, c('Akkermansia', 'Dialister')]))
#' @references
#' \itemize{
#' \item{}{Livina et al. (2010). Potential analysis reveals changing
#' number of climate states during the last 60 kyr.
#' \emph{Climate of the Past}, 6, 77-82.}
#' \item{}{Lahti et al. (2014). Tipping elements of the human intestinal
#' ecosystem. \emph{Nature Communications} 5:4344.}
#' }
#' @keywords utilities
multimodality <- function(x, peak.threshold=1, bw.adjust=1,
bs.iter=100, min.density=1, verbose=TRUE) {
if (is.vector(x)) {
# Add small noise to enable robust density estimation
# (identical values may cause failure)
x <- x + rnorm(length(x), sd=sd(x)/100)
m <- potential_analysis(x, bw.adjust=bw.adjust, bs.iter=bs.iter,
min.density=min.density)
ret <- list(score=1 - m$unimodality.support,
modes=m$modes, results=m)
return(ret)
} else {
# Univariate potential analysis for all taxa with full data
potential.results <- list()
nmodes <- c()
if (is.null(rownames(x))) {
rownames(x) <- as.character(seq_len(nrow(x)))
}
for (tax in rownames(x)) {
if (verbose) {
message(tax)
}
m <- multimodality(as.numeric(x[tax, ]), peak.threshold,
bw.adjust, bs.iter, min.density, verbose)
nmodes[[tax]] <- m$modes
potential.results[[tax]] <- m
}
multimodality.score <- vapply(potential.results, function(x) {
1 - x$unimodality.support
}, 1)
ret <- list(score=multimodality.score,
modes=nmodes,
results=potential.results)
}
ret
}
#' @title Sarle's Bimodality Coefficient
#' @description Sarle's bimodality coefficient.
#' @param x Data vector for which bimodality will be quantified
#' @param bs.iter Bootstrap iterations
#' @param type Score type ('Sarle.finite.sample' or 'Sarle.asymptotic')
#' @return Bimodality score
#' @examples
#' # b <- bimodality_sarle(rnorm(50), type='Sarle.finite.sample')
#' @details The coefficient lies in (0, 1).
#'
#' The 'Sarle.asymptotic' version is defined as
#' \deqn{b=(g^2 + 1) / k}.
#' This is coefficient of bimodality from Ellison AM Am. J. Bot. 1987,
#' for microbiome analysis it has been used for instance in
#' Shade et al. 2014.
#'
#' The formula for 'Sarle.finite.sample' (SAS 2012):
#'
#' \deqn{b=\frac{g^2 + 1}{k + (3(n-1)^2)/((n-2)(n-3))}}
#' where n is sample size and
#'
#' In both formulas, \eqn{g} is sample skewness and \eqn{k} is the kth
#' standardized moment (also called the sample kurtosis, or
#' excess kurtosis).
#'
#' @references
#' \itemize{
#'   \item{}{Shade et al. mBio 5(4):e01371-14, 2014.}
#'   \item{}{Ellison AM (1987) Am J Botany 74(8):1280-1288.}
#'   \item{}{SAS Institute Inc. (2012). SAS/STAT 12.1 user's guide. Cary, NC.}
#'   \item{}{To cite the microbiome R package, see citation('microbiome')}
#' }
#' @author Contact: Leo Lahti \email{microbiome-admin@@googlegroups.com}
#' @seealso Check the dip.test from the \pkg{DIP} package for a
#' classical test of multimodality.
#' @keywords utilities
bimodality_sarle <- function(x, bs.iter=1, type="Sarle.finite.sample") {
g <- skew(x)
k <- kurtosis(x)
if (type == "Sarle.asymptotic") {
s <- (1 + g^2)/(k + 3)
} else if (type == "Sarle.finite.sample") {
n <- length(x)
s <- (g^2 + 1)/(k + (3 * (n - 1)^2)/((n - 2) * (n - 3)))
}
if (bs.iter > 1) {
s <- c()
for (i in seq_len(bs.iter)) {
xbs <- sample(x, replace=TRUE)
s[[i]] <- bimodality_sarle(xbs, type=type)
}
s <- mean(s)
}
s
}
# Inspired by moments::kurtosis but rewritten. Internal.
kurtosis <- function (x, na.rm=TRUE)
{
if (is.matrix(x)) {
k <- apply(x, 2, kurtosis, na.rm=na.rm)
return(k)
} else if (is.vector(x)) {
if (na.rm) {
x <- x[!is.na(x)]
}
n <- length(x)
k <- n * sum((x - mean(x))^4)/(sum((x - mean(x))^2)^2)
return(k)
} else if (is.data.frame(x)) {
k <- vapply(x, kurtosis, 1, na.rm = na.rm)
return(k)
} else {
kurtosis(as.vector(x), na.rm = na.rm)
return(k)
}
}
bimodality <- bimodality(pseq0.log10, method = "potential_analysis", bs.iter = 20, verbose = T)
b <- bimodality(c(rnorm(100, mean=0), rnorm(100, mean=5)), bs.iter=5)
b <- bimodality(c(rnorm(100, mean=0), rnorm(100, mean=5)), bs.iter=5)
# Pick the most and least bimodal taxa as examples
unimodal  <- names(sort(bimodality))[[1]]
# Log10 abundance for a selected taxonomic group
tax <- bimodal
# We set the tipping point manually in this example
# Bimodality hotplot:
# Consider a unique sample from each subject: the baseline time point
p <- hotplot(pseq0, tax, tipping.point = 0.005)
rmarkdown::render('Bimodality.Rmd','all')
p <- boxplot_abundance(pseq, x = "time", y = "Akkermansia", line = "subject") + scale_y_log10()
# Load libraries
library(microbiome)
library(ggplot2)
library(dplyr)
# Probiotics intervention example data
data(peerj32) # Source: https://peerj.com/articles/32/
pseq <- peerj32$phyloseq # Rename the example data
p <- boxplot_abundance(pseq, x = "time", y = "Akkermansia", line = "subject") + scale_y_log10()
print(p)
library(MASS)
library(tidyr)
# Analyse specific taxa
tax <- "Akkermansia"
# Pick the signal (abundance) for this tax
sample_data(pseq)$signal <- get_sample(pseq, tax)
# Negative binomial test with group and gender included
res <- glm.nb(signal ~ group + sex, data = meta(pseq))
# Show the results
print(coef(summary(res)))
library(MASS)
library(tidyr)
# Analyse specific taxa
tax <- "Akkermansia"
# Pick the signal (abundance) for this tax
sample_data(pseq)$signal <- get_sample(pseq, tax)
# Negative binomial test with group and gender included
res <- glm.nb(signal ~ group + sex, data = meta(pseq))
# Show the results
print(coef(summary(res)))
rmarkdown::render('Negativebinomial.Rmd','all')
rmarkdown::render('Tutorial.Rmd','all')

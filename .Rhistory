library(knitr)
print(head(kable((df))))
# Identify top taxa based on standard ANOVA
source(system.file("extdata/check_anova.R", package = "microbiome"))
ano <- check_anova(pseq, "nationality");
ano$log2FC <- log2(ano$ave.AFR) - log2(ano$ave.AAM)
taxa.anova <- as.character(subset(ano, padj < 0.01 & abs(log2FC) > log2(2))$taxa)
# lowPick the top taxa based on DESEq2
taxa.deseq <- subset(res, padj < 0.01 & abs(log2FoldChange) > log2(2))$taxon
# Check overlap
# Most DESEq2 taxa are confirmed with ANOVA
library(gplots)
venn( list(ANOVA = taxa.anova,DESeq2 = taxa.deseq) )
# Also the est p-values are well correlated (higher not so)
mf<-data.frame(df$padj, ano$padj)
p<-ggplot(mf, aes(x = log10(df$padj), y = log10(ano$padj))) + xlab('DESeq2 adjusted p-value') + ylab('ANOVA adjusted p-value')
p<- p + geom_point()
#plot(xlim=log10(df$padj), log10(ano$padj), type = 'l', xlim = "DESeq2 adjusted p-value",  ylim("ANOVA adjusted p-value"))
venn( list(ANOVA = taxa.anova,DESeq2 = taxa.deseq))
print(p)
# Identify top taxa based on standard ANOVA
source(system.file("extdata/check_anova.R", package = "microbiome"))
ano <- check_anova(pseq, "nationality");
ano$log2FC <- log2(ano$ave.AFR) - log2(ano$ave.AAM)
taxa.anova <- as.character(subset(ano, padj < 0.01 & abs(log2FC) > log2(2))$taxa)
# lowPick the top taxa based on DESEq2
taxa.deseq <- subset(res, padj < 0.01 & abs(log2FoldChange) > log2(2))$taxon
# Check overlap
# Most DESEq2 taxa are confirmed with ANOVA
library(gplots)
#venn( list(ANOVA = taxa.anova,DESeq2 = taxa.deseq) )
# Also the est p-values are well correlated (higher not so)
mf<-data.frame(df$padj, ano$padj)
p<-ggplot(mf, aes(x = log10(df$padj), y = log10(ano$padj))) + xlab('DESeq2 adjusted p-value') + ylab('ANOVA adjusted p-value')
p<- p + geom_point()
#plot(xlim=log10(df$padj), log10(ano$padj), type = 'l', xlim = "DESeq2 adjusted p-value",  ylim("ANOVA adjusted p-value"))
venn( list(ANOVA = taxa.anova,DESeq2 = taxa.deseq))
print(p)
p<-ggplot(mf, aes(x = log10(df$padj), y = log10(ano$padj)), color = df.padj) + xlab('DESeq2 adjusted p-value') + ylab('ANOVA adjusted p-value')
p<- p + geom_point()
print(p)
# Also the est p-values are well correlated (higher not so)
mf<-data.frame(df$padj, ano$padj)
p<-ggplot(mf, aes(x = log10(df$padj), y = log10(ano$padj)), color = 'df.padj') + xlab('DESeq2 adjusted p-value') + ylab('ANOVA adjusted p-value')
p<- p + geom_point()
p
getwd()
rmarkdown::render('deseq2.rmd','html_document')
times <- c()
# Render all files
for (myfile in fs) {
times[[myfile]] <- system.time(rmarkdown::render(myfile))
}
library(microbiome)
library(DirichletMultinomial)
library(reshape2)
library(magrittr)
library(dplyr)
# Load example data
data(dietswap)
pseq <- dietswap
# To speed up, only consider the core taxa
# that are prevalent at 0.1% relative abundance in 50% of the samples
# (note that this is not strictly correct as information is
# being discarded; one alternative would be to aggregate rare taxa)
pseq.comp <- microbiome::transform(pseq, "compositional")
taxa <- core_members(pseq.comp, detection = 0.1/100, prevalence = 50/100)
pseq <- prune_taxa(taxa, pseq)
# Pick the OTU count matrix
# and convert it into samples x taxa format
dat <- abundances(pseq)
count <- as.matrix(t(dat))
fit <- mclapply(1:3, dmn, count = count, verbose=TRUE)
lplc <- sapply(fit, laplace) # AIC / BIC / Laplace
aic  <- sapply(fit, AIC) # AIC / BIC / Laplace
bic  <- sapply(fit, BIC) # AIC / BIC / Laplace
#plot(lplc, type="b", xlab="Number of Dirichlet Components", ylab="Model Fit")
#lines(aic, type="b", lty = 2)
#lines(bic, type="b", lty = 3)
best <- fit[[which.min(lplc)]]
mixturewt(best)
ass <- apply(mixture(best), 1, which.max)
for (k in seq(ncol(fitted(best)))) {
d <- melt(fitted(best))
colnames(d) <- c("OTU", "cluster", "value")
d <- subset(d, cluster == k) %>%
# Arrange OTUs by assignment strength
arrange(value) %>%
mutate(OTU = factor(OTU, levels = unique(OTU))) %>%
# Only show the most important drivers
filter(abs(value) > quantile(abs(value), 0.8))
p <- ggplot(d, aes(x = OTU, y = value)) +
geom_bar(stat = "identity") +
coord_flip() +
labs(title = paste("Top drivers: community type", k))
print(p)
}
getwd()
rmarkdown::render('README.rmd','md_document')
getwd()
setwd('D:/Seafile/My Library/Important/New_microbiome/tutorials/main')
rmarkdown::render('README.rmd','md_document')
getwd()
setwd('D:/Seafile/My Library/Important/New_microbiome/tutorials')
setwd('D:/Seafile/My Library/Important/New_microbiome/tutorials/main')
setwd('D:/Seafile/My Library/Important/New_microbiome/tutorials')
rmarkdown::render('README.rmd','md_document')
getwd()
rmarkdown::render('README.rmd','md_document')
rmarkdown::render('README.rmd','md_document')
knit2 = function(...) {
pdf.options(encoding='ISOLatin2.enc')
knitr::knit(...)
}
rmarkdown::render('README.rmd','md_document')
rmarkdown::render('README.rmd','md_document')
getwd()
rmarkdown::render('README.rmd','md_document')
getwd()
setwd('D:/Seafile/My Library/Important/New_microbiome/tutorials/main')
times <- c()
# Render all files
for (myfile in fs) {
times[[myfile]] <- system.time(rmarkdown::render(myfile))
}
rmarkdown::render("info.Rmd")
theme_set(theme_bw(40))
df <- as.data.frame(t(sapply(times, identity)))
df$file <- rownames(df)
dfm <- as_tibble(melt(df, id = "file")) %>%
filter(variable %in% c("user.self", "elapsed")) %>%
arrange(value) %>%
mutate(file = factor(file, levels = unique(file)))
library(tibble)
theme_set(theme_bw(40))
df <- as.data.frame(t(sapply(times, identity)))
df$file <- rownames(df)
dfm <- as_tibble(melt(df, id = "file")) %>%
filter(variable %in% c("user.self", "elapsed")) %>%
arrange(value) %>%
mutate(file = factor(file, levels = unique(file)))
df <- as.data.frame(t(sapply(times, identity)))
df$file <- rownames(df)
dfm <- as_tibble(melt(df, id = "file")) %>%
filter(variable %in% c("user.self", "elapsed")) %>%
arrange(value) %>%
mutate(file = factor(file, levels = unique(file)))
library(tibble)
theme_set(theme_bw(40))
df <- as.data.frame(t(sapply(times, identity)))
df$file <- rownames(df)
dfm <- as_tibble(melt(df, id = "file")) %>%
filter(variable %in% c("user.self", "elapsed")) %>%
arrange(value) %>%
mutate(file = factor(file, levels = unique(file)))
library(magrittr)
theme_set(theme_bw(40))
df <- as.data.frame(t(sapply(times, identity)))
df$file <- rownames(df)
dfm <- as_tibble(melt(df, id = "file")) %>%
filter(variable %in% c("user.self", "elapsed")) %>%
arrange(value) %>%
mutate(file = factor(file, levels = unique(file)))
dfm <- as_tibble(melt(df, id = "file")) %>%
filter(variable %>% c("user.self", "elapsed")) %>%
arrange(value) %>%
mutate(file = factor(file, levels = unique(file)))
f<-4
f1<-2
f2<-c(1,2,3,4,5,6,7)
f %in f2
f %in% f2
98 %in% f2
library(tibble)
library(magrittr)
theme_set(theme_bw(40))
df <- as.data.frame(t(sapply(times, identity)))
df$file <- rownames(df)
dfm <- as_tibble(melt(df, id = "file")) %>%
filter(variable %in% c("user.self", "elapsed")) %>%
arrange(value) %>%
mutate(file = factor(file, levels = unique(file)))
times <- c()
# Render all files
for (myfile in fs) {
times[[myfile]] <- system.time(rmarkdown::render(myfile))
}
rmarkdown::render("info.Rmd")
# Download the required R packages and then the HITChip Atlas data set
library(microbiome)
data(atlas1006)
tab <- alpha(atlas1006, index = c("shannon", "invsimpson"))
library(knitr)
kable(head(tab))
getwd()
setwd('D:/Seafile/My Library/Important/New_microbiome/tutorials')
times <- c()
# Render all files
for (myfile in fs) {
times[[myfile]] <- system.time(rmarkdown::render(myfile))
}
rmarkdown::render("info.Rmd")
library(microbiome)
library(DirichletMultinomial)
library(reshape2)
library(magrittr)
library(dplyr)
# Load example data
data(dietswap)
pseq <- dietswap
# To speed up, only consider the core taxa
# that are prevalent at 0.1% relative abundance in 50% of the samples
# (note that this is not strictly correct as information is
# being discarded; one alternative would be to aggregate rare taxa)
pseq.comp <- microbiome::transform(pseq, "compositional")
taxa <- core_members(pseq.comp, detection = 0.1/100, prevalence = 50/100)
pseq <- prune_taxa(taxa, pseq)
# Pick the OTU count matrix
# and convert it into samples x taxa format
dat <- abundances(pseq)
count <- as.matrix(t(dat))
fit <- mclapply(1:3, dmn, count = count, verbose=TRUE)
lplc <- sapply(fit, laplace) # AIC / BIC / Laplace
aic  <- sapply(fit, AIC) # AIC / BIC / Laplace
bic  <- sapply(fit, BIC) # AIC / BIC / Laplace
#plot(lplc, type="b", xlab="Number of Dirichlet Components", ylab="Model Fit")
#lines(aic, type="b", lty = 2)
#lines(bic, type="b", lty = 3)
best <- fit[[which.min(lplc)]]
mixturewt(best)
ass <- apply(mixture(best), 1, which.max)
for (k in seq(ncol(fitted(best)))) {
d <- melt(fitted(best))
colnames(d) <- c("OTU", "cluster", "value")
d <- subset(d, cluster == k) %>%
# Arrange OTUs by assignment strength
arrange(value) %>%
mutate(OTU = factor(OTU, levels = unique(OTU))) %>%
# Only show the most important drivers
filter(abs(value) > quantile(abs(value), 0.8))
p <- ggplot(d, aes(x = OTU, y = value)) +
geom_bar(stat = "identity") +
coord_flip() +
labs(title = paste("Top drivers: community type", k))
print(p)
}
lplc <- sapply(fit, laplace) # AIC / BIC / Laplace
aic  <- sapply(fit, AIC) # AIC / BIC / Laplace
bic  <- sapply(fit, BIC) # AIC / BIC / Laplace
#plot(lplc, type="b", xlab="Number of Dirichlet Components", ylab="Model Fit")
#lines(aic, type="b", lty = 2)
#lines(bic, type="b", lty = 3)
best <- fit[[which.min(lplc)]]
lplc <- sapply(fit, laplace) # AIC / BIC / Laplace
aic  <- sapply(fit, AIC) # AIC / BIC / Laplace
bic  <- sapply(fit, BIC) # AIC / BIC / Laplace
plot(lplc, type="b", xlab="Number of Dirichlet Components", ylab="Model Fit")
lplc <- sapply(fit, laplace) # AIC / BIC / Laplace
aic  <- sapply(fit, AIC) # AIC / BIC / Laplace
bic  <- sapply(fit, BIC) # AIC / BIC / Laplace
#plot(lplc, type="b", xlab="Number of Dirichlet Components", ylab="Model Fit")
#lines(aic, type="b", lty = 2)
#lines(bic, type="b", lty = 3)
#best <- fit[[which.min(lplc)]]
mixturewt(best)
mixturewt(best)
data.frame(pi = object@mixture$Weight, theta = colSums(fitted(object)))
fit <- mclapply(1:3, dmn, count = count, verbose=TRUE)
mixturewt(best)
ass <- apply(mixture(best), 1, which.max)
for (k in seq(ncol(fitted(best)))) {
d <- melt(fitted(best))
colnames(d) <- c("OTU", "cluster", "value")
d <- subset(d, cluster == k) %>%
# Arrange OTUs by assignment strength
arrange(value) %>%
mutate(OTU = factor(OTU, levels = unique(OTU))) %>%
# Only show the most important drivers
filter(abs(value) > quantile(abs(value), 0.8))
p <- ggplot(d, aes(x = OTU, y = value)) +
geom_bar(stat = "identity") +
coord_flip() +
labs(title = paste("Top drivers: community type", k))
print(p)
}
library(BiocInstaller)
source("http://www.bioconductor.org/biocLite.R")
library(BiocManager)
source("https://bioconductor.org/install")
library(BiocManager)
source("https://bioconductor.org/install")
library(BiocManager)
source("https://bioconductor.org/install/#install-R")
library(devtools) # Load the devtools package
install_github("microbiome/microbiome") # Install the package
library(BiocManager)
source("https://bioconductor.org")
source("https://bioconductor.org/biocLite.R")
source("https://bioconductor.org/install")
library(BiocManager)
#source("https://bioconductor.org/install")
useDevel()
library(BiocManager)
#source("https://bioconductor.org/install")
#useDevel()
BiocManager::install("microbiome")
version('microbiome')
BiocManager::version('microbiome')
BiocManager::version()
microbiome::version()
library(BiocManager)
#source("https://bioconductor.org/install")
#useDevel()
BiocManager::install("microbiome")
remove.packages("microbiomeutilities", lib="~/R/win-library/3.6")
remove.packages("microbiome", lib="~/R/win-library/3.6")
# Installing from Bioconductor
source("http://www.bioconductor.org/biocLite.R")
# Installing from Bioconductor
#source("http://www.bioconductor.org/biocLite.R")
BiocManager::install("MASS")
# Installing from CRAN
install.packages("sorvi")
# Installing from Github
library(devtools)
install_github("antagomir/netresponse")
library(netresponse)
library(netresponse)
BiocManager::version()
library(BiocManager)
#source("https://bioconductor.org/install")
#useDevel()
BiocManager::install(version='devel')
BiocManager::install("microbiome")
library(microbiome)
library(BiocManager)
#source("https://bioconductor.org/install")
#useDevel()
BiocManager::install(version='devel')
BiocManager::install("microbiome")
n
library(devtools) # Load the devtools package
install_github("microbiome/microbiome") # Install the package
library(devtools) # Load the devtools package
getwd()
getwd()
library(microbiome) # Load libraries
library(phyloseq)
library(dplyr)
library(reshape2)
library(knitr)
data(peerj32)
pseq <- peerj32$phyloseq    # Rename data
# Pick data subset (DI samples from Phylum Bacteroidetes)
pseq2 <- pseq %>%
subset_taxa(Phylum == "Bacteroidetes") %>%
subset_samples(group == "LGG")
# Z transformed abundance data
pseqz <- microbiome::transform(pseq2, "Z")
library(microbiome) # Load libraries
library(phyloseq)
library(dplyr)
library(reshape2)
library(knitr)
data(peerj32)
pseq <- peerj32$phyloseq    # Rename data
# Pick data subset (DI samples from Phylum Bacteroidetes)
pseq2 <- pseq %>%
subset_taxa(Phylum == "Bacteroidetes") %>%
subset_samples(group == "LGG")
# Z transformed abundance data
pseqz <- microbiome::transform(pseq2, "Z")
# Plot the abundances heatmap
heat(melt(abundances(pseqz)), "Var1", "Var2", "value")
# Sort the matrix rows and cols directly
xo <- neat(abundances(pseqz), method = "NMDS", distance = "euclidean")
# Heatmap visualization
heat(melt(xo), "Var1", "Var2", "value")
# or use a shortcut to sorting rows (or columns) if just the order was needed
sorted.rows <- neatsort(abundances(pseqz), "rows", method = "NMDS", distance = "euclidean")
# Load example data
otu <- peerj32$microbes
lipids <- peerj32$lipids
# Define data sets to cross-correlate
x <- log10(otu) # OTU Log10 (44 samples x 130 genera)
y <- as.matrix(lipids) # Lipids (44 samples x 389 lipids)
# Cross correlate data sets
correlations <- associate(x, y, method = "spearman", mode = "matrix", p.adj.threshold = 0.05, n.signif = 1)
# Or, alternatively, the same output is also available in a handy table format
correlation.table <- associate(x, y, method = "spearman", mode = "table", p.adj.threshold = 0.05, n.signif = 1)
kable(head(correlation.table))
p <- heat(correlation.table, "X1", "X2", fill = "Correlation", star = "p.adj", p.adj.threshold = 0.05)
print(p)
# Order the rows and columns with levels argument if needed:
correlation.table$X1 <- factor(correlation.table$X1, levels = unique(as.character(correlation.table$X1)))
correlation.table$X2 <- factor(correlation.table$X2, levels = unique(as.character(correlation.table$X2)))
# Set black-and-white theme
library(ggplot2)
theme_set(theme_bw())
# Pick only the correlations with q<0.05
# Note: this will leave other cells empty
library(dplyr)
subtable <- filter(correlation.table, p.adj < 0.05)
# Arrange the figure
p <- ggplot(subtable, aes(x = X1, y = X2, fill = Correlation))
p <- p + geom_tile()
p <- p + scale_fill_gradientn("Correlation",
breaks = seq(from = -1, to = 1, by = 0.2),
colours = c("darkblue", "blue", "white", "red", "darkred"),
limits = c(-1,1))
# Polish texts
p <- p + theme(axis.text.x=element_text(angle = 90))
p <- p + xlab("") + ylab("")
# Mark the most significant cells with stars
p <- p + geom_text(data = subset(correlation.table, p.adj < 0.02),
aes(x = X1, y = X2, label = "+"), col = "white", size = 5)
# Plot
print(p)
theme_set(theme_bw(20))
df <- correlation.table
p <- ggplot(df, aes(X1, X2, group=X2))
p <- p + geom_tile(aes(fill = Correlation))
p <- p + geom_text(aes(fill = df$Correlation, label = round(df$Correlation, 1)), size = 2)
p <- p + scale_fill_gradientn("Correlation",
breaks = seq(from = -1, to = 1,  by = 0.25),
colours = c("blue", "white", "red"),
limits = c(-1, 1))
p <- p + theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
p <- p + xlab("") + ylab("")
print(p)
library(GGally)
ggcorr(x[, 1:10], method = c("pairwise", "spearman"), nbreaks = 20, hjust = 0.75)
ggcorr(x[, 1:10], method = c("pairwise", "spearman"), nbreaks = 20, geom = "circle")
ggcorr(x[, 1:10], method = c("pairwise", "spearman"), nbreaks = 20, label = TRUE, label_alpha = TRUE)
ggcorr(data = NULL, cor_matrix = cor(x[, 1:10], use = "everything"), low = "steelblue", mid = "white", high = "darkred", midpoint = 0)
library(microbiome) # Load libraries
library(phyloseq)
library(dplyr)
library(reshape2)
library(knitr)
data(peerj32)
pseq <- peerj32$phyloseq    # Rename data
# Pick data subset (DI samples from Phylum Bacteroidetes)
pseq2 <- pseq %>%
subset_taxa(Phylum == "Bacteroidetes") %>%
subset_samples(group == "LGG")
# Z transformed abundance data
pseqz <- microbiome::transform(pseq2, "Z")
# Plot the abundances heatmap
heat(melt(abundances(pseqz)), "Var1", "Var2", "value")
# Sort the matrix rows and cols directly
xo <- neat(abundances(pseqz), method = "NMDS", distance = "euclidean")
# Heatmap visualization
heat(melt(xo), "Var1", "Var2", "value")
# or use a shortcut to sorting rows (or columns) if just the order was needed
sorted.rows <- neatsort(abundances(pseqz), "rows", method = "NMDS", distance = "euclidean")
# Load example data
otu <- peerj32$microbes
lipids <- peerj32$lipids
# Define data sets to cross-correlate
x <- log10(otu) # OTU Log10 (44 samples x 130 genera)
y <- as.matrix(lipids) # Lipids (44 samples x 389 lipids)
# Cross correlate data sets
correlations <- associate(x, y, method = "spearman", mode = "matrix", p.adj.threshold = 0.05, n.signif = 1)
# Or, alternatively, the same output is also available in a handy table format
correlation.table <- associate(x, y, method = "spearman", mode = "table", p.adj.threshold = 0.05, n.signif = 1)
kable(head(correlation.table))
p <- heat(correlation.table, "X1", "X2", fill = "Correlation", star = "p.adj", p.adj.threshold = 0.05)
# Order the rows and columns with levels argument if needed:
correlation.table$X1 <- factor(correlation.table$X1, levels = unique(as.character(correlation.table$X1)))
correlation.table$X2 <- factor(correlation.table$X2, levels = unique(as.character(correlation.table$X2)))
# Set black-and-white theme
library(ggplot2)
theme_set(theme_bw())
# Pick only the correlations with q<0.05
# Note: this will leave other cells empty
library(dplyr)
subtable <- filter(correlation.table, p.adj < 0.05)
# Arrange the figure
p <- ggplot(subtable, aes(x = X1, y = X2, fill = Correlation))
p <- p + geom_tile()
p <- p + scale_fill_gradientn("Correlation",
breaks = seq(from = -1, to = 1, by = 0.2),
colours = c("darkblue", "blue", "white", "red", "darkred"),
limits = c(-1,1))
# Polish texts
p <- p + theme(axis.text.x=element_text(angle = 90))
p <- p + xlab("") + ylab("")
# Mark the most significant cells with stars
p <- p + geom_text(data = subset(correlation.table, p.adj < 0.02),
aes(x = X1, y = X2, label = "+"), col = "white", size = 5)
# Plot
print(p)
brew remove pandoc
library(knitr)
library(microbiome)
library(microbiome)
library(microbiome) # Load libraries
library(phyloseq)
library(dplyr)
library(reshape2)
library(knitr)
data(peerj32)
pseq <- peerj32$phyloseq    # Rename data
# Pick data subset (DI samples from Phylum Bacteroidetes)
pseq2 <- pseq %>%
subset_taxa(Phylum == "Bacteroidetes") %>%
subset_samples(group == "LGG")
# Z transformed abundance data
pseqz <- microbiome::transform(pseq2, "Z")
# Plot the abundances heatmap
heat(melt(abundances(pseqz)), "Var1", "Var2", "value")
